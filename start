#!/usr/local/bin/python

from flask import Flask, request, Response
import cv2
import datetime
import numpy
import sys
import time

def get_time():
    return datetime.datetime.fromtimestamp(time.time()).strftime('%Y-%m-%d %H:%M:%S')

app = Flask(__name__)
app.config['UPLOAD_FOLDER'] = '/tmp'

@app.route('/crop', methods=['POST'])
def crop_out_ruler():
    if 'image' not in request.files:
        return Response("{'error': 'No image part'}", status=400, mimetype='application/json')

    filestorage = request.files['image']

    if filestorage.filename == '':
        return Response("{'error': 'No selected file'}", status=400, mimetype='application/json')

    if not (filestorage.filename.endswith('.jpg') or filestorage.filename.endswith('.tif')):
        return Response("{'error': 'Unsupported file type'}", status=400, mimetype='application/json')

    try:
        ruler_color = [
            int(request.form['red']),
            int(request.form['green']),
            int(request.form['blue'])
        ]
        grayvariation = int(request.form['grayvariation'])
    except KeyError:
        return Response("{'error': 'Missing required form values'}", status=400, mimetype='application/json')

    morph_open_kernel = numpy.ones((5, 5), numpy.uint8)
    morph_close_kernel = numpy.ones((20, 20), numpy.uint8)
    border_width = 100
    nudge_crop_in = 10
    test_color = (255, 0, 0)
    test_width = 20
    
    sys.stdout.write('{} loading {}.\n'.format(get_time(), filestorage.filename))

    filestr = filestorage.read()
    npimg = numpy.fromstring(filestr, numpy.uint8)
    img = cv2.imdecode(npimg, cv2.IMREAD_COLOR)

    if img is None:
        raise ValueError
    if not img.any():
        raise ValueError

    sys.stdout.write('{} pre-processing.\n'.format(get_time()))
    # selecting gray objects
    lower_limit_for_gray = numpy.array([ruler_color[0] - grayvariation, ruler_color[1] - grayvariation, ruler_color[2] - grayvariation], dtype = numpy.uint8)
    upper_limit_for_gray = numpy.array([ruler_color[0] + grayvariation, ruler_color[1] + grayvariation, ruler_color[2] + grayvariation], dtype = numpy.uint8)
    gray_only = cv2.inRange(img, lower_limit_for_gray, upper_limit_for_gray)
    
    # despeckling to remove noise.
    gray_only = cv2.morphologyEx(gray_only, cv2.MORPH_OPEN, morph_open_kernel)
    
    # filling in gaps to remove noise.
    gray_only = cv2.morphologyEx(gray_only, cv2.MORPH_CLOSE, morph_close_kernel)
    
    # adding a border.
    gray_only = cv2.copyMakeBorder(gray_only, border_width, border_width, border_width, border_width, cv2.BORDER_CONSTANT, value=[0, 0, 0])
    
    # getting a bitonal image.
    ret, threshold = cv2.threshold(gray_only, 127, 255, cv2.THRESH_BINARY)
    
    # getting contours.
    _, contours, hierarchy = cv2.findContours(threshold.copy(), cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
    
    ruler = None
    
    # find the largest countour with four sides- assume it is the ruler.
    contours = sorted(contours, key = cv2.contourArea, reverse = True)[:10]
    for c in contours:
        peri = cv2.arcLength(c, True)
        approx = cv2.approxPolyDP(c, 0.02 * peri, True)
        if len(approx) == 4:
            # remember to take off the 100 pixel boundary we added above. 
            ruler = numpy.array(list(map(lambda c: [[c[0][0] - border_width, c[0][1] - border_width]], approx)))
            break
    
    if ruler is not None:
        sys.stdout.write('{} found ruler.\n'.format(get_time()))
    
        # get x coordinates of all points in ruler, sort so the one closes to the center of the image is first.
        height, width, channels = img.shape
        points_x_coordinates = list(map(lambda c: c[0][0], ruler.tolist()))
        points_x_coordinates = list(sorted(points_x_coordinates, key=lambda x: abs(width - x)))
    
        # get the lowest or highest coordinate depending on which side of the page the ruler is on.
        if points_x_coordinates[0] > width / 2:
            x = points_x_coordinates[-1]
        else:
            x = points_x_coordinates[0]
    
        # return ruler coordinates. 
        if x < width / 2:
            return Response("{{'success': {{'x1': {}, 'x2': {}, 'y1': {}, 'y2': {}}}}}".format(x, width, 0, height), status=200, mimetype='application/json')
        else:
            return Response("{{'success': {{'x1': {}, 'x2': {}, 'y1': {}, 'y2': {}}}}}".format(0, x, 0, height), status=200, mimetype='application/json')
    else:
        sys.stdout.write('{} no ruler found.\n'.format(get_time()))

if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0')
